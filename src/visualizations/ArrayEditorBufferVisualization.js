import {
  defineArrowheads,
  renderVariableBox,
  renderGenericNode, // We'll use this more for buffer cells later
  isAddress,
  truncateAddress,
  generateOrthogonalPath,
} from "../utils/visualizationUtils";

export const renderArrayEditorBufferVisualization = (
  contentGroup,
  width,
  height,
  operation,
  memorySnapshot,
  snapshotIdentifier
) => {
  const snapshotId = snapshotIdentifier || "AEBViz";
  console.log(
    `[${snapshotId}] Rendering ArrayEditorBuffer. Op:`,
    operation,
    "Snap:",
    memorySnapshot
  );

  const state = memorySnapshot || operation.state || {};
  const localVariables = state.localVariables || {};
  const instanceVariables = state.instanceVariables || {};
  const addressObjectMap = state.addressObjectMap || {};

  // Styles adapted from ArrayVectorVisualization for consistency
  const styles = {
    varBox: {
      width: 220, // Slightly wider for AEB if needed, else keep AVV's 200
      headerHeight: 25,
      fieldHeight: 25,
      fieldSpacing: 5,
      padding: 10,
      fill: "#ffffff",
      stroke: "#94a3b8",
      titleFill: "#94a3b8",
      titleFillOpacity: 0.3,
      titleStroke: "#94a3b8",
      textFill: "#334155",
      valueTextFill: "#334155",
      addressValueFill: "#0ea5e9",
      fieldRectFill: "white",
      fieldRectStroke: "#e2e8f0",
      fontSize: "12px",
      titleFontSize: "13px",
      fontFamily: "Inter, sans-serif",
    },
    intermediateBox: {
      // For the box showing "array: 0xADDRESS"
      width: 180,
      height: 40, // Or calculated by renderGenericNode
      fill: "#f0fdf4", // Light green - distinct from cells
      stroke: "#86efac",
      titleFill: "#dcfce7",
      titleStroke: "#86efac",
      titleTextFill: "#15803d",
      keyTextFill: "#15803d",
      valueTextFill: "#15803d",
      addressTextFill: "#0c702f",
      fieldRectFill: "none",
      fieldRectStroke: "#a7f3d0",
      fontSize: "12px",
      titleFontSize: "12px",
      padding: 5,
      fontFamily: "Inter, sans-serif",
    },
    bufferCell: {
      // Similar to AVV's arrayCell
      width: 60, // AEB cells can be narrower than AVV's general array cells
      height: 50,
      fill: "#ffffff",
      stroke: "#94a3b8",
      textFill: "#334155",
      indexTextFill: "#64748b",
      fontSize: "14px",
      indexFontSize: "10px",
      indexPartitionHeight: 18,
      spacing: 0,
      fontFamily: "Inter, sans-serif",
      inactiveFill: "#f8f9fa", // For cells beyond 'size' but within 'capacity'
      inactiveStroke: "#dee2e6",
      inactiveTextFill: "#adb5bd",
    },
    connection: {
      strokeWidth: 1.5,
      defaultColor: "#64748b",
      instanceVarColor: "#334155",
      cellPointerColor: "#16a34a", // If cells themselves can point
      iteratorColor: "#fb923c", // For iterators like 'cursor'
      cornerRadius: 8,
      // Marker IDs will be generated by defineArrowheads
      markerEndIdDefault: "aeb-arrowhead-default",
      markerEndIdInstVar: "aeb-arrowhead-instvar",
      markerEndIdCellPtr: "aeb-arrowhead-cellptr",
      markerEndIdIterator: "aeb-arrowhead-iterator",
    },
    layout: {
      varBoxMarginX: 30,
      topOfVisY: 30,
      boxSpacing: 40,
      boxSpacingVertical: 50,
      cellSpacing: 0,
      nodesStartXOffset: 60, // Space between var boxes and first buffer element
      layerSpacingY: 70,
      textFallbackOffsetX: 10,
      textFallbackOffsetY: 5,
      elementsPerRow: 10, // For buffer cells if they wrap
      rowSpacingY: 20, // For buffer cells if they wrap
    },
    colors: {
      text: "#334155",
      errorText: "#ef4444",
      addressText: "#0ea5e9",
    },
    fontFamily: "Inter, sans-serif",
    fontSize: "12px",
  };

  let defs = contentGroup.select("defs");
  if (defs.empty()) {
    defs = contentGroup.append("defs");
  }
  // Simpler marker config based on connection colors
  const markerConfig = {
    [styles.connection.markerEndIdDefault]: {
      color: styles.connection.defaultColor,
      size: 8,
    },
    [styles.connection.markerEndIdInstVar]: {
      color: styles.connection.instanceVarColor,
      size: 8,
    },
    [styles.connection.markerEndIdCellPtr]: {
      color: styles.connection.cellPointerColor,
      size: 8,
    },
    [styles.connection.markerEndIdIterator]: {
      color: styles.connection.iteratorColor,
      size: 8,
    },
  };
  defineArrowheads(defs, markerConfig);

  const nodePositions = {};
  const allConnections = [];
  let currentLayoutY = styles.layout.topOfVisY;
  const firstColX = styles.layout.varBoxMarginX;

  // --- 1. Render Instance Variables ---
  if (instanceVariables && Object.keys(instanceVariables).length > 0) {
    const instVarBoxResult = renderVariableBox(
      contentGroup,
      "Instance Variables",
      instanceVariables,
      firstColX,
      currentLayoutY,
      styles.varBox,
      "instance",
      isAddress
    );
    if (instVarBoxResult) {
      allConnections.push(...(instVarBoxResult.connectionPoints || []));
      nodePositions["instance_vars_box"] = {
        x: firstColX,
        y: currentLayoutY,
        width: styles.varBox.width,
        height: instVarBoxResult.height,
      };
      currentLayoutY +=
        instVarBoxResult.height + styles.layout.boxSpacingVertical;
    } else {
      currentLayoutY +=
        styles.varBox.headerHeight + styles.layout.boxSpacingVertical; // Minimal space if no vars
    }
  } else {
    currentLayoutY +=
      styles.varBox.headerHeight + styles.layout.boxSpacingVertical;
  }

  // --- 2. Render Local Variables (below instance variables) ---
  if (localVariables && Object.keys(localVariables).length > 0) {
    const locVarBoxResult = renderVariableBox(
      contentGroup,
      "Local Variables",
      localVariables,
      firstColX,
      currentLayoutY,
      styles.varBox,
      "local",
      isAddress
    );
    if (locVarBoxResult) {
      allConnections.push(...(locVarBoxResult.connectionPoints || []));
      nodePositions["local_vars_box"] = {
        x: firstColX,
        y: currentLayoutY,
        width: styles.varBox.width,
        height: locVarBoxResult.height,
      };
      currentLayoutY +=
        locVarBoxResult.height + styles.layout.boxSpacingVertical;
    }
  }
  // Reset currentLayoutY for buffer elements, they start near top, right of var boxes
  let bufferSystemStartY = styles.layout.topOfVisY;
  let bufferSystemStartX =
    firstColX + styles.varBox.width + styles.layout.boxSpacing;

  // --- 3. Identify Main Buffer Address ---
  let bufferArrayAddress = null;
  let actualArrayVarNameForLookup = null;
  const potentialArrayKeys = [
    "array",
    "buffer",
    "data",
    "m_array",
    "m_buffer",
    "m_data",
  ];

  if (instanceVariables && typeof instanceVariables === "object") {
    for (const key of potentialArrayKeys) {
      if (instanceVariables.hasOwnProperty(key)) {
        const value = instanceVariables[key];
        if (typeof value === "string" && isAddress(value)) {
          bufferArrayAddress = value;
          actualArrayVarNameForLookup = key;
          console.log(
            `[${snapshotId}] Found buffer array address: ${bufferArrayAddress} from key: ${actualArrayVarNameForLookup}`
          );
          break;
        }
      }
    }
  }
  const mainBufferVarConnection = allConnections.find(
    (c) =>
      c.varName === actualArrayVarNameForLookup &&
      c.sourceName.startsWith("instance-")
  );

  // --- 4. Render Intermediate Buffer Address Box (if buffer address found) ---
  const intermediateBoxId = bufferArrayAddress
    ? `intermediate_buffer_box_${bufferArrayAddress}`
    : null;
  let intermediateBoxRenderedWidth = 0;
  if (bufferArrayAddress) {
    const titleText = actualArrayVarNameForLookup
      ? `${actualArrayVarNameForLookup}: ${truncateAddress(bufferArrayAddress)}`
      : `Buffer: ${truncateAddress(bufferArrayAddress)}`;

    console.log(
      `[${snapshotId}] Attempting to render Intermediate Buffer Box. Title: "${titleText}", ID: ${intermediateBoxId}`
    );

    const intermediateNodeSpec = {
      id: intermediateBoxId,
      x: bufferSystemStartX,
      y: bufferSystemStartY,
      title: titleText,
      fields: {},
      width: styles.intermediateBox.width,
    };
    const renderedIntermediateBox = renderGenericNode(
      contentGroup,
      intermediateNodeSpec,
      styles.intermediateBox,
      nodePositions,
      isAddress,
      truncateAddress,
      snapshotId
    );
    if (renderedIntermediateBox) {
      intermediateBoxRenderedWidth = renderedIntermediateBox.width;
      // Buffer cells will start to the right of this intermediate box
      bufferSystemStartX +=
        intermediateBoxRenderedWidth + styles.layout.cellSpacing;
    }
  } else if (bufferArrayAddress) {
    console.warn(
      `[${snapshotId}] Buffer address ${bufferArrayAddress} found, but original variable name not identified.`
    );
  }

  // --- 5. Render Buffer Cells ---
  const bufferCellsGroup = contentGroup
    .append("g")
    .attr("id", `buffer_cells_group_${snapshotId}`);
  let actualBufferData = [];
  if (
    bufferArrayAddress &&
    addressObjectMap &&
    addressObjectMap[bufferArrayAddress]
  ) {
    actualBufferData = addressObjectMap[bufferArrayAddress];
    if (!Array.isArray(actualBufferData)) {
      console.warn(
        `[${snapshotId}] Expected array data for buffer at ${bufferArrayAddress} but found:`,
        actualBufferData
      );
      actualBufferData = []; // Treat as empty if not an array
    }
  }

  const capacity =
    instanceVariables?.capacity !== undefined
      ? parseInt(instanceVariables.capacity, 10)
      : actualBufferData.length;
  const logicalSize =
    instanceVariables?.size !== undefined
      ? parseInt(instanceVariables.size, 10)
      : actualBufferData.length;

  if (bufferArrayAddress && actualBufferData.length === 0 && capacity > 0) {
    // If addressObjectMap is empty for this address, but capacity is known, render empty cells
    for (let i = 0; i < capacity; i++) {
      actualBufferData.push(undefined); // Fill with undefined to render empty cells up to capacity
    }
  }

  if (actualBufferData.length > 0) {
    actualBufferData.forEach((value, index) => {
      if (index >= capacity) return; // Don't render beyond capacity if data is somehow longer

      const cellX =
        bufferSystemStartX +
        index * (styles.bufferCell.width + styles.bufferCell.spacing);
      const cellY = bufferSystemStartY; // Assuming single row for now, aligns with intermediateBox
      const cellId = `buffer_cell_${
        actualArrayVarNameForLookup || "main"
      }_${index}_${snapshotId}`;

      const isActiveCell = index < logicalSize;
      const cellStyle = {
        ...styles.bufferCell,
        fill: isActiveCell
          ? styles.bufferCell.fill
          : styles.bufferCell.inactiveFill,
        stroke: isActiveCell
          ? styles.bufferCell.stroke
          : styles.bufferCell.inactiveStroke,
        textFill: isActiveCell
          ? styles.bufferCell.textFill
          : styles.bufferCell.inactiveTextFill,
        indexTextFill: isActiveCell
          ? styles.bufferCell.indexTextFill
          : styles.bufferCell.inactiveTextFill,
      };

      const cellGroup = bufferCellsGroup
        .append("g")
        .attr("id", cellId)
        .attr("transform", `translate(${cellX}, ${cellY})`);
      cellGroup
        .append("rect")
        .attr("width", cellStyle.width)
        .attr("height", cellStyle.height)
        .attr("fill", cellStyle.fill)
        .attr("stroke", cellStyle.stroke)
        .attr("stroke-width", 1);
      cellGroup
        .append("line") // Index partition line
        .attr("x1", 0)
        .attr("y1", cellStyle.indexPartitionHeight)
        .attr("x2", cellStyle.width)
        .attr("y2", cellStyle.indexPartitionHeight)
        .attr("stroke", cellStyle.stroke)
        .attr("stroke-width", 0.5);
      cellGroup
        .append("text") // Index text
        .attr("x", cellStyle.width / 2)
        .attr("y", cellStyle.indexPartitionHeight / 2)
        .attr("dy", ".35em")
        .attr("text-anchor", "middle")
        .attr("fill", cellStyle.indexTextFill)
        .style("font-size", cellStyle.indexFontSize)
        .text(index);
      cellGroup
        .append("text") // Value text
        .attr("x", cellStyle.width / 2)
        .attr(
          "y",
          cellStyle.indexPartitionHeight +
            (cellStyle.height - cellStyle.indexPartitionHeight) / 2
        )
        .attr("dy", ".35em")
        .attr("text-anchor", "middle")
        .attr("fill", cellStyle.textFill)
        .style("font-size", cellStyle.fontSize)
        .text(value === undefined ? "" : truncateAddress(String(value), 6)); // Show empty for undefined, truncate others

      nodePositions[cellId] = {
        x: cellX,
        y: cellY,
        width: cellStyle.width,
        height: cellStyle.height,
        address: cellId,
      };
    });
  } else if (!bufferArrayAddress) {
    console.log(
      `[${snapshotId}] No bufferArrayAddress found, so no buffer cells or specific message will be rendered in the buffer area.`
    );
  } else {
    bufferCellsGroup
      .append("text")
      .attr("x", bufferSystemStartX + styles.layout.textFallbackOffsetX)
      .attr(
        "y",
        bufferSystemStartY +
          styles.bufferCell.height / 2 +
          styles.layout.textFallbackOffsetY
      )
      .attr("text-anchor", "start")
      .text("Buffer empty or data not found.")
      .attr("fill", styles.colors.text);
  }

  // --- 5.5. Render Other Arrays/Buffers from addressObjectMap ---
  let maxKnownYSoFar = currentLayoutY; // Y after instance/local vars
  if (nodePositions[intermediateBoxId]) {
    maxKnownYSoFar = Math.max(
      maxKnownYSoFar,
      nodePositions[intermediateBoxId].y +
        nodePositions[intermediateBoxId].height
    );
  }
  // Consider height of rendered cells for main buffer (assuming single row for now)
  if (actualBufferData.length > 0) {
    maxKnownYSoFar = Math.max(
      maxKnownYSoFar,
      bufferSystemStartY + styles.bufferCell.height
    );
  }

  let otherArraysStartY = maxKnownYSoFar + styles.layout.boxSpacingVertical * 2; // Extra spacing before other arrays section
  const otherArraysStartX = styles.layout.varBoxMarginX; // Align to the left
  let currentOtherArrayY = otherArraysStartY;

  console.log(
    `[${snapshotId}] Looking for other arrays in addressObjectMap. Starting Y: ${currentOtherArrayY}`
  );

  Object.entries(addressObjectMap).forEach(([address, data]) => {
    if (Array.isArray(data) && address !== bufferArrayAddress) {
      console.log(`[${snapshotId}] Found other array at address: ${address}`);
      const otherBufferData = data;
      if (otherBufferData.length === 0) {
        console.log(`[${snapshotId}] Skipping empty other array at ${address}`);
        return;
      }

      const otherIntermediateBoxId = `intermediate_other_buffer_box_${address}`;
      let currentXForOtherArray = otherArraysStartX;

      // Render intermediate box for this other array
      const otherIntermediateNodeSpec = {
        id: otherIntermediateBoxId,
        x: currentXForOtherArray,
        y: currentOtherArrayY,
        title: `(Other) ${truncateAddress(address)}`,
        fields: {},
        width: styles.intermediateBox.width * 0.8, // Slightly smaller intermediate box
        height: styles.intermediateBox.height * 0.9,
      };
      const renderedOtherIntermediateBox = renderGenericNode(
        contentGroup,
        otherIntermediateNodeSpec,
        {
          ...styles.intermediateBox,
          fill: "#e9ecef",
          stroke: "#ced4da",
          titleTextFill: "#495057",
        }, // Muted style for other arrays
        nodePositions,
        isAddress,
        truncateAddress,
        snapshotId
      );

      if (renderedOtherIntermediateBox) {
        currentXForOtherArray +=
          renderedOtherIntermediateBox.width + styles.layout.cellSpacing;
      }

      // Render cells for this other array
      const otherCapacity = otherBufferData.length; // No separate capacity/size for these for now
      const otherLogicalSize = otherBufferData.length;

      otherBufferData.forEach((value, index) => {
        const cellX =
          currentXForOtherArray +
          index * (styles.bufferCell.width + styles.bufferCell.spacing);
        const cellY = currentOtherArrayY;
        const cellId = `other_buffer_cell_${address}_${index}_${snapshotId}`;
        const cellStyle = styles.bufferCell; // Use default active style for now

        const cellGroup = contentGroup
          .append("g")
          .attr("id", cellId)
          .attr("transform", `translate(${cellX}, ${cellY})`);
        cellGroup
          .append("rect")
          .attr("width", cellStyle.width)
          .attr("height", cellStyle.height)
          .attr("fill", cellStyle.fill)
          .attr("stroke", cellStyle.stroke)
          .attr("stroke-width", 1);
        cellGroup
          .append("line")
          .attr("x1", 0)
          .attr("y1", cellStyle.indexPartitionHeight)
          .attr("x2", cellStyle.width)
          .attr("y2", cellStyle.indexPartitionHeight)
          .attr("stroke", cellStyle.stroke)
          .attr("stroke-width", 0.5);
        cellGroup
          .append("text")
          .attr("x", cellStyle.width / 2)
          .attr("y", cellStyle.indexPartitionHeight / 2)
          .attr("dy", ".35em")
          .attr("text-anchor", "middle")
          .attr("fill", cellStyle.indexTextFill)
          .style("font-size", cellStyle.indexFontSize)
          .text(index);
        cellGroup
          .append("text")
          .attr("x", cellStyle.width / 2)
          .attr(
            "y",
            cellStyle.indexPartitionHeight +
              (cellStyle.height - cellStyle.indexPartitionHeight) / 2
          )
          .attr("dy", ".35em")
          .attr("text-anchor", "middle")
          .attr("fill", cellStyle.textFill)
          .style("font-size", cellStyle.fontSize)
          .text(truncateAddress(String(value), 6));

        nodePositions[cellId] = {
          x: cellX,
          y: cellY,
          width: cellStyle.width,
          height: cellStyle.height,
          address: cellId,
        };
      });
      // Increment Y for the next "other" array system
      currentOtherArrayY +=
        Math.max(
          styles.bufferCell.height,
          renderedOtherIntermediateBox ? renderedOtherIntermediateBox.height : 0
        ) + styles.layout.rowSpacingY;
    }
  });

  // --- 6. Draw Connections ---
  const connectionsGroup = contentGroup
    .append("g")
    .attr("class", "connections-group");
  console.log(
    `[${snapshotId}] Node Positions before drawing connections:`,
    JSON.parse(JSON.stringify(nodePositions))
  );
  console.log(
    `[${snapshotId}] All Connections before drawing loop:`,
    JSON.parse(JSON.stringify(allConnections))
  );

  allConnections.forEach((conn, idx) => {
    let sourceContainerBoxPosData = null;
    if (conn.sourceName && conn.sourceName.startsWith("instance-")) {
      sourceContainerBoxPosData = nodePositions["instance_vars_box"];
    } else if (conn.sourceName && conn.sourceName.startsWith("local-")) {
      sourceContainerBoxPosData = nodePositions["local_vars_box"];
    }

    let actualSourceEgressPoint = conn.sourceCoords;
    let finalTargetPointForPath = null;
    let targetBoxPos = null;
    let pathOrientationHint = "auto";
    let markerId = styles.connection.markerEndIdDefault;
    let strokeColor = styles.connection.defaultColor;

    // Target Identification Logic
    if (
      conn.targetAddress &&
      nodePositions[intermediateBoxId] &&
      conn.targetAddress === bufferArrayAddress &&
      conn.varName === actualArrayVarNameForLookup
    ) {
      // Pointer from the main array variable in instance_vars to the intermediate buffer box
      targetBoxPos = nodePositions[intermediateBoxId];
      markerId = styles.connection.markerEndIdInstVar;
      strokeColor = styles.connection.instanceVarColor;
      console.log(
        `[${snapshotId}] Conn ${idx}: Instance var '${conn.varName}' to Intermediate Buffer Box ${intermediateBoxId}`
      );
    } else if (conn.targetAddress && isAddress(conn.targetAddress)) {
      // General address pointer - could be to another intermediate box (not implemented yet) or a cell
      // For now, let's assume it might target the main intermediate box if address matches
      if (
        nodePositions[intermediateBoxId] &&
        conn.targetAddress === bufferArrayAddress
      ) {
        targetBoxPos = nodePositions[intermediateBoxId];
        console.log(
          `[${snapshotId}] Conn ${idx}: General pointer '${conn.varName}' to Intermediate Buffer Box ${intermediateBoxId}`
        );
      } else {
        // Try to find if it points to a cell (more complex, needs cell IDs in nodePositions)
        const targetCellKey = Object.keys(nodePositions).find(
          (key) =>
            key.startsWith("buffer_cell_") &&
            nodePositions[key].address === conn.targetAddress
        );
        if (targetCellKey) {
          targetBoxPos = nodePositions[targetCellKey];
          markerId = styles.connection.markerEndIdCellPtr;
          strokeColor = styles.connection.cellPointerColor;
          console.log(
            `[${snapshotId}] Conn ${idx}: Pointer '${conn.varName}' to Cell ${targetCellKey}`
          );
        }
      }
    } else if (conn.targetIndex !== undefined && actualArrayVarNameForLookup) {
      // Pointer to an index (e.g. cursor)
      const targetCellId = `buffer_cell_${actualArrayVarNameForLookup}_${conn.targetIndex}_${snapshotId}`;
      if (nodePositions[targetCellId]) {
        targetBoxPos = nodePositions[targetCellId];
        markerId = styles.connection.markerEndIdIterator; // Or specific marker for iterators
        strokeColor = styles.connection.iteratorColor;
        console.log(
          `[${snapshotId}] Conn ${idx}: Iterator '${conn.varName}' to Cell Index ${conn.targetIndex} (ID: ${targetCellId})`
        );
      }
    }

    if (actualSourceEgressPoint && targetBoxPos && sourceContainerBoxPosData) {
      const Y_THRESHOLD = (styles.varBox.fieldHeight || 25) * 1.5;
      const HORIZONTAL_OVERSHOOT = 20;
      const INITIAL_HORIZONTAL_SEGMENT_FOR_OVERLAP = 20;
      const cornerRadius = styles.connection.cornerRadius;

      const sourceOverallMidX =
        sourceContainerBoxPosData.x + sourceContainerBoxPosData.width / 2;
      const sourceFieldActualY = actualSourceEgressPoint.y;
      const targetOverallMidX = targetBoxPos.x + targetBoxPos.width / 2;
      const targetOverallMidY = targetBoxPos.y + targetBoxPos.height / 2;

      const deltaXOverallMid = Math.abs(targetOverallMidX - sourceOverallMidX);
      const deltaYDecisionMid = Math.abs(
        targetOverallMidY - sourceFieldActualY
      );

      const chosenEgressSide =
        targetOverallMidX < sourceOverallMidX ? "left" : "right";
      if (chosenEgressSide === "left") {
        actualSourceEgressPoint.x = sourceContainerBoxPosData.x;
      } else {
        actualSourceEgressPoint.x =
          sourceContainerBoxPosData.x + sourceContainerBoxPosData.width;
      }

      if (
        deltaYDecisionMid <= Y_THRESHOLD ||
        conn.varName === actualArrayVarNameForLookup
      ) {
        // Favor H-V-H for direct array pointer
        pathOrientationHint = "H-V-H";
        finalTargetPointForPath = {
          x:
            chosenEgressSide === "left"
              ? targetBoxPos.x + targetBoxPos.width
              : targetBoxPos.x,
          y: targetOverallMidY,
        };
      } else {
        pathOrientationHint = "H-V_to_target_top"; // Or another suitable hint
        const sourceRightX =
          sourceContainerBoxPosData.x + sourceContainerBoxPosData.width;
        const targetRightX = targetBoxPos.x + targetBoxPos.width;
        const overlap =
          Math.max(sourceContainerBoxPosData.x, targetBoxPos.x) <
          Math.min(sourceRightX, targetRightX);

        if (!overlap) {
          let approachingEdgeX =
            chosenEgressSide === "right" ? targetBoxPos.x : targetRightX;
          let overshotX =
            chosenEgressSide === "right"
              ? approachingEdgeX + HORIZONTAL_OVERSHOOT
              : approachingEdgeX - HORIZONTAL_OVERSHOOT;
          finalTargetPointForPath = {
            x: overshotX,
            y:
              sourceFieldActualY < targetOverallMidY
                ? targetBoxPos.y
                : targetBoxPos.y + targetBoxPos.height,
          };
        } else {
          let turnX =
            chosenEgressSide === "right"
              ? actualSourceEgressPoint.x +
                INITIAL_HORIZONTAL_SEGMENT_FOR_OVERLAP
              : actualSourceEgressPoint.x -
                INITIAL_HORIZONTAL_SEGMENT_FOR_OVERLAP;
          finalTargetPointForPath = {
            x: turnX,
            y:
              sourceFieldActualY < targetOverallMidY
                ? targetBoxPos.y
                : targetBoxPos.y + targetBoxPos.height,
          };
        }
      }

      let initialOffset = 15;
      if (pathOrientationHint === "H-V-H") {
        const xDistForOffset = deltaXOverallMid / 2 - cornerRadius * 2;
        const yDistForOffset =
          Math.abs(finalTargetPointForPath.y - actualSourceEgressPoint.y) * 0.4;
        initialOffset = Math.max(
          5,
          Math.min(30, xDistForOffset, yDistForOffset)
        );
      }

      const path = generateOrthogonalPath(
        actualSourceEgressPoint,
        finalTargetPointForPath,
        cornerRadius,
        pathOrientationHint,
        initialOffset,
        null
      );

      if (path) {
        connectionsGroup
          .append("path")
          .attr("d", path)
          .attr("fill", "none")
          .attr("stroke", strokeColor)
          .attr("stroke-width", styles.connection.strokeWidth)
          .attr("marker-end", `url(#${markerId})`);
      } else {
        console.warn(
          `[${snapshotId}] Path generation failed for connection ${idx}:`,
          conn
        );
      }
    } else {
      console.warn(
        `[${snapshotId}] Skipping connection ${idx} due to missing source/target data:`,
        conn,
        actualSourceEgressPoint,
        targetBoxPos,
        sourceContainerBoxPosData
      );
    }
  });

  console.log(
    `[${snapshotId}] ArrayEditorBufferVisualization rendering complete.`
  );
};
